using System;
using System.Windows;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Threading;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        private DispatcherTimer _timer;
        private TimeSpan _currentTime;
        private TimeSpan _totalTime;
        private int _lastDisplayedSeconds; // Stores the integer part of seconds last shown in TimeDisplay

        private int _batteryState = 0;
        private readonly Color[] _batteryColors = { Colors.Red, Colors.Yellow, Colors.Green };
        private readonly double[] _batteryHeights = { 0.2, 0.6, 1.0 };
        private DispatcherTimer _batteryTimer;

        public MainWindow()
        {
            InitializeComponent();

            ProgressIndicator.Fill = new SolidColorBrush(Colors.DodgerBlue);
            BatteryBar.Fill = new SolidColorBrush(Colors.LightGreen);

            Loaded += (s, e) =>
            {
                InitProgressAnimation();
                InitBatteryAnimation();
            };
        }

        private void InitProgressAnimation()
        {
            _totalTime = TimeSpan.FromSeconds(5);
            _currentTime = _totalTime;

            // Initial setup of display before timer starts
            _lastDisplayedSeconds = (int)Math.Ceiling(_currentTime.TotalSeconds);
            TimeDisplay.Text = TimeSpan.FromSeconds(_lastDisplayedSeconds).ToString(@"hh\:mm\:ss");
            UpdateProgressBar(0); // Progress is 0% at the start

            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromMilliseconds(50) // Tick frequently for smooth animation
            };

            _timer.Tick += (s, e) =>
            {
                TimeSpan timeAtTickStart = _currentTime; // Capture time at the beginning of this tick's logic

                // If _currentTime was zero at the start of this tick, reset to _totalTime for a new cycle
                if (timeAtTickStart == TimeSpan.Zero)
                {
                    _currentTime = _totalTime;
                }

                _currentTime = _currentTime.Subtract(_timer.Interval); // Decrement current time

                bool justReachedZero = false;
                if (_currentTime.TotalMilliseconds < 0) // Check if time has run out
                {
                    _currentTime = TimeSpan.Zero; // Clamp to zero
                    // Check if it transitioned from positive to zero in this exact tick
                    if (timeAtTickStart > TimeSpan.Zero)
                    {
                        justReachedZero = true;
                    }
                }

                // Calculate progress
                double elapsedRatio = 0.0;
                if (_totalTime.TotalMilliseconds > 0) // Avoid division by zero if _totalTime is zero
                {
                    elapsedRatio = (_totalTime.TotalMilliseconds - _currentTime.TotalMilliseconds) / _totalTime.TotalMilliseconds;
                }
                elapsedRatio = Math.Max(0.0, Math.Min(1.0, elapsedRatio)); // Clamp ratio to [0,1]

                double progress = elapsedRatio * 100.0;
                UpdateProgressBar(progress);

                // Determine the seconds value to display
                int secondsToDisplay = (int)Math.Ceiling(_currentTime.TotalSeconds); // Use ceiling for countdown effect
                if (_currentTime == TimeSpan.Zero) // Always display "0" when time is exactly zero
                {
                    secondsToDisplay = 0;
                }

                // Update the time display text if necessary
                if (_lastDisplayedSeconds != secondsToDisplay || justReachedZero || timeAtTickStart == TimeSpan.Zero)
                {
                    TimeDisplay.Text = TimeSpan.FromSeconds(secondsToDisplay).ToString(@"hh\:mm\:ss");
                    _lastDisplayedSeconds = secondsToDisplay;
                }
            };
            _timer.Start();
        }

        private void UpdateProgressBar(double progress)
        {
            if (ProgressBackground.ActualWidth > 0)
            {
                ProgressIndicator.Width = progress * ProgressBackground.ActualWidth / 100;
                ProgressText.Text = $"{Math.Round(progress)}%";
            }
        }

        private void InitBatteryAnimation()
        {
            _batteryTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(2)
            };
            _batteryTimer.Tick += (s, e) =>
            {
                _batteryState = (_batteryState + 1) % 3;

                double containerHeight = BatteryContainer.ActualHeight;

                Storyboard colorStoryboard = new Storyboard();
                ColorAnimation colorAnim = new ColorAnimation
                {
                    To = _batteryColors[_batteryState],
                    Duration = TimeSpan.FromSeconds(0.5)
                };
                Storyboard.SetTarget(colorAnim, BatteryBar);
                Storyboard.SetTargetProperty(colorAnim, new PropertyPath("(Shape.Fill).(SolidColorBrush.Color)"));
                colorStoryboard.Children.Add(colorAnim);
                colorStoryboard.Begin(this);

                BatteryBar.Height = containerHeight * _batteryHeights[_batteryState];
            };
            _batteryTimer.Start();
        }

        protected override void OnClosing(System.ComponentModel.CancelEventArgs e)
        {
            _timer?.Stop();
            _batteryTimer?.Stop();
            base.OnClosing(e);
        }
    }
}
